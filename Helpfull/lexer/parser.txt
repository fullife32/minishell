REDIRECTIONS:

... [redirection] [filename] ...

if < > << >> ALWAYS filename after
TOUJOURS le filename apres les redirections.
retourne toujours retour erreur de l'access ?

apres les redirections peuvent etre placées n'importe ou dans l'ensemble de la cmd
(avant la commande apres la commande...)
> fileout < filein1 cmd <filein2



multi > file1 > file2 > file3
tous les fichiers sont creer s'ils ne le sont pas mais seul 
le dernier sera stdout.
les fichiers intermediaires sont vides
multi < file1 < file2 ...
va ouvrir chaque file mais n'utiliser que le dernier.
donc si un file n'existe pas (open failed) la commande s'arrete.


lesredirections ecrasent les pipes
cmd < filename | cmd2   == (cmd < filename) | cmd2

cmd > filename | cmd2  == (cmd > filemane) | cmd2
ici filename contiendra cmd pipe sera vides

cat < file1 | cat < file2 == cat file 1 | (cat < file2)
ici stdin du deuxieme cat sera file2 et non le pipe.


while line
	token->next = get_next_token

//get next token
while isspace 
	line++
if (not eof)
	get_this_token
return token


// if metacharacter : 
static char	all metacharacter

while c !=metacharacter
	meta++
return metacaracter
or return 0;


//get this token
if  *line ismetacharacter
	len = t_fonction gettokenmetacharacter[metacaracter](*line, &token)
else get word
	*line += len;
return token;




//// parsing

if get_this_cmd[token->type](actual token, command)




if < > >> : io_file		< > >>	WORD(filename)


if << : io_here			<<	WORD(delimiter)


if WORD :  if first WORD = cmd name
			else COMD_ARGS

if PIPE : cmd prev = PIPE


	then if ' ' : not interpret \

	if " " : interpret escape \" \\ \' \$  and $VARIABLE




Grammaire : 

pipe : pipe sequence

pipe sequence: 	cmd	
				pipe sequence | linebreak cmd

cmd:			simple_cmd

simple_cmd	:	cmd_prefix cmd_word cmd_suffix
				cmd_prefix cmd_word
				cmd_prefix
				cmd_name cmd_suffix
				cmd_name

cmd_name : 		WORD    (the first word)

cmd_word : 		WORD	not first word

cmd_prefix		IO_REDIRECT
				cmd_prefix IO_REDIRECT
				ASSIGNEMENT_WORD

redirection		IO_REDIRECT
				redirect_list IO_REDIRECT

IO_REDIRECT : 	iofile
				ionumber iofile
				iohere
				ionumber iohere

iofile			< > << >> + filename

filename		WORD






/* CHECK error synthax

DOUBLE QUOTE = %2
SIMPLE_QUOTE = %2
redirections need WORD after
:

HEREDOC
OUVRE LES INPUT/OUTPUT  (ecrase le heredock ou les pipes)
ESSAIE DE TROUVERLA COMMANDE

<< tata cat < Makefile 
> dfg
> dfg
> dfg
> dfg
> dfg
> tata
# **************************************************************************** #
#                                                                              #
(...)

 << cat -e | iii < sdfsdfsdfsdf
> cat
bash: sdfsdfsdfsdf: Aucun fichier ou dossier de ce type
bash: -e : commande introuvable


< cat -e | sdfsdfsdfsdf
bash: sdfsdfsdfsdf : commande introuvable
bash: cat: Aucun fichier ou dossier de ce type

< cat -e
bash: cat: Aucun fichier ou dossier de ce type

cat -e >
bash: erreur de syntaxe près du symbole inattendu « newline »

cat -e >> | echo hello
bash: erreur de syntaxe près du symbole inattendu « | »

HEREDOC need WORD DELIMITER after
<< cat -e
> cat -e
> cat
bash: -e : commande introuvable

SPECIALPARAMETER need ?(=last exit status) or WORD after (= variable)
 if WORD is no others needed cité au dessus, its a command
 all WORD after command is arguments.

struct cmd_status
{
	double_quote = nb
	simple_quote = nb
	pipe_with_nothing_after / before =
	redirection_with_no_word_after = 


}*/

/* ALL : NOT REQUIRED FOR MINISHELL
enum e_token_type
{
	WORD,					// not special type
	STRING,					// inside quotes
	SEQUENCE,				//	;
	GROUP_LEFT,				//	(
	GROUP_RIGHT,			//	)
	PIPE,					//	|
	OR,						// 	||
	BACKGROUND,				//	&
	AND, 					//	&&
	INPUT_REDIRECTION,		//	<
	OUTPUT_REDIRECTION,		//	>
	HERE_DOC,				//	<<
	APPEND,					//	>>
	SIMPE_QUOTE,			//	'
	DOUBLE_QUOTE,			//	"
	SPECIAL_PARAMETER,		//	$
};
*/

/*
t_token	*lexer_line(char *line)
{
	split_line = split_minishell_line()
	if (line)
		return NULL;
	t_token all_token = malloc token();
	if (!token)
		return NULL;
	token = get_all_token(split_line);
	free_double_tab(line);
	if (!token)
		return NULL
	return token;
}

get_next token(**token)
NEED: 	
		new token = malloc
		len = 0
		token type = getmetacharacter(line);
		token value = get_token value(line, &len)
		line += len;
		if (*token == NULL)
			*token = new_token;
		else
			token->next = new_token;
		return (len);


t_token **create_lexer_token_minishell(char *line)
{
	token = malloc **token;

	len = get_next_token(token, line)
	line += token->len
	while (*line)
	{
		if (lineisspace)
			line++;
		else
			token->next = get_next_token(line)
			line += token->len
			token = token next;
	}
}


CMD PARSER



parsing

token **t;

while *t
{
	cmd = get_next_cmd(token, &cmd_status)
}

*/